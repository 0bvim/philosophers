#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <semaphore.h>
#include <sys/time.h>
#include <string.h>

#define NUM_PHILOSOPHERS 5
#define THINKING 0
#define HUNGRY 1
#define EATING 2
#define LEFT (philosopher_number + 4) % NUM_PHILOSOPHERS
#define RIGHT (philosopher_number + 1) % NUM_PHILOSOPHERS

// Global variables
sem_t *mutex;
sem_t *s;

// Function to format and print the log messages
void print_log(int philosopher_number, const char *action) {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    long long timestamp = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
    printf("%lld %d %s\n", timestamp, philosopher_number, action);
}

// Philosopher function
void philosopher(int philosopher_number, int time_to_die, int time_to_eat, int time_to_sleep, int num_must_eat) {
    int num_eaten = 0;
    struct timeval last_meal_time;
    gettimeofday(&last_meal_time, NULL);

    while (1) {
        print_log(philosopher_number, "is thinking");
        usleep(random() % 500000 + 1);

        sem_wait(mutex);
        print_log(philosopher_number, "has taken a fork");
        sem_post(mutex);

        sem_wait(mutex);
        print_log(philosopher_number, "has taken a fork");
        sem_post(mutex);

        sem_wait(mutex);
        print_log(philosopher_number, "is eating");
        sem_post(mutex);

        usleep(time_to_eat * 1000);

        sem_wait(mutex);
        print_log(philosopher_number, "is sleeping");
        sem_post(mutex);

        usleep(time_to_sleep * 1000);

        gettimeofday(&last_meal_time, NULL);

        if (num_must_eat > 0) {
            num_eaten++;
            if (num_eaten == num_must_eat) {
                sem_close(mutex);
                sem_close(s);
                exit(0);
            }
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc < 5 || argc > 6) {
        printf("Usage: %s <number_of_philosophers> <time_to_die> <time_to_eat> <time_to_sleep> [<number_of_times_each_philosopher_must_eat>]\n", argv[0]);
        return 1;
    }

    int num_philosophers = atoi(argv[1]);
    int time_to_die = atoi(argv[2]);
    int time_to_eat = atoi(argv[3]);
    int time_to_sleep = atoi(argv[4]);
    int num_must_eat = (argc == 6) ? atoi(argv[5]) : -1;

    pid_t pid;
    mutex = sem_open("/mutex", O_CREAT, 0644, 1);
    s = sem_open("/s", O_CREAT, 0644, 0);

    for (int i = 0; i < num_philosophers; i++) {
        pid = fork();

        if (pid == 0) { // Child process
            philosopher(i + 1, time_to_die, time_to_eat, time_to_sleep, num_must_eat);
            exit(0);
        } else if (pid < 0) {
            perror("Fork failed");
            return 1;
        }
    }

    // Wait for all child processes to finish
    for (int i = 0; i < num_philosophers; i++) {
        waitpid(-1, NULL, 0);
    }

    sem_unlink("/mutex");
    sem_unlink("/s");

    return 0;
}

